# 왜 QPlan을 사용해야 하는가?

QPlan은 AI가 요청을 분석해 **즉석에서 실행 계획을 만들고 바로 실행**할 수 있게 하는  
언어 중립적·안전 기반 워크플로우 DSL이다.  
목표는 “코드 생성”이 아니라 **실시간 자동 계획 + 실행**이다.

---

# 1. AI가 ‘실시간 실행계획’을 만들 때 발생하는 공통 문제를 해결한다

AI가 일반 프로그래밍 언어로 실행 로직을 구성하려고 하면  
언어 종류와 상관없이 다음 문제가 생긴다:

- 로직 구성 방식이 매번 달라짐  
- 비동기 흐름/조건/병렬 처리 실수가 잦음  
- 불필요한 추론으로 계획이 복잡해짐  
- 실행 환경 의존이 커짐  
- 부작용(side effects) 위험  
- 재현성 부족  
- 계획과 실행이 분리되어 일관성 유지 어려움  

즉, **AI가 임의의 코드로 “실행 흐름을 직접 구성”하는 방식은  
언어에 관계없이 불안정하다.**

QPlan은 이를 해결하기 위해 다음을 고정한다:

- Grammar  
- 실행 규칙  
- 변수 컨텍스트  
- 모듈 사용 방식  

AI는 “계획만 만든다”, 실행은 엔진이 맡는다.
- 물론 실행step에 AI요청을 포함할 수 있다.
---

# 2. 모듈 확장성 — 기능을 무한히 확장할 수 있다

QPlan의 모든 기능은 모듈(ActionModule)로 재사용된다.

예:
- DB 조회  
- API 호출  
- 텍스트/문서 처리  
- 파일 시스템  
- Slack/Email 등 메시징  
- AI 호출  
- DevOps 작업  
- 사내 전용 기능  

모듈은 metadata(id, inputs, usage)를 가지므로  
AI는 문서화된 방식으로만 기능을 사용한다.

→ **개발자가 기능을 만든다 → AI가 조립해 실행계획을 만든다.**

---

# 3. 실행계획을 AI가 만들고, 엔진이 안전하게 즉시 실행한다

QPlan 구조는 매우 명확하다:

- **AI의 역할**: “어떤 모듈을 어떤 순서로 사용할지” 계획  
- **엔진의 역할**: AST 기반으로 안전하고 일관되게 실행  

이 방식은 어떤 언어로 구현된 모듈이든 동일하게 적용된다.

AI가 다음처럼 결정하면:

```
file read path="./data.json" -> raw
json op="parse" data=raw -> parsed
http op="post" url="/save" body=parsed -> result
```

엔진은 이를 그대로 실행한다.

언어가 무엇인지 전혀 중요하지 않다.

---

# 4. 비동기(Future), 병렬(Parallel) 제어를 DSL로 보장

AI가 언어 기반으로 비동기 흐름을 구성하면 복잡한 추론이 필요하지만  
QPlan에서는 추론이 불필요하다:

```
future delay=500 value="A" -> f1
future delay=500 value="B" -> f2
join futures="f1,f2" -> out
```

또는:

```
parallel concurrency=3 {
    api call op="stats" -> s
    api call op="user" -> u
    api call op="orders" -> o
}
```

→ AI가 실시간 계획을 만들 때 가장 어려운 영역을 완전히 단순화한다.

---

# 5. ExecutionContext — 변수와 상태 관리 자동화

범용 언어의 실행계획은 항상 상태/변수 스코프 관리 문제를 동반한다.

QPlan에서는:

```
math op="add" a=1 b=2 -> sum
echo msg=sum
```

ExecutionContext가 모든 값을 자동 저장/전달한다.  
AI는 변수 스코프를 판단할 필요가 없다.

---

# 6. 결정론적 실행 — 자동화 시스템에 필수

AI가 만든 실행 로직을 코드 형태로 구성하면:

- 구조가 매번 다름  
- 흐름이 조금씩 변함  
- 의도치 않은 로직이 섞임  

QPlan은:

- 문법 고정  
- 모듈 고정  
- 실행 규칙 고정  

즉, **같은 요구 → 같은 실행계획 → 같은 결과**  
AI 기반 자동화에서 필수다.

---

# 7. 언어 중립적이고 AI-Friendly

QPlan은 특정 언어를 대체하려는 것이 아니다.  
오히려 “언어를 선택하기 전에 실행계획을 만드는 계층”이다.

- Grammar 명확  
- 모듈 메타데이터 제공  
- usage 예시 제공  
- 예측 가능한 계획만 생성하도록 제한  

→ 어떤 언어를 사용하든, 어떤 모델을 사용하든 일관된 워크플로우 생성 가능.

---

# 결론: QPlan을 사용해야 하는 이유 (v4)

1) AI가 “코드를 생성하는 것”이 아니라 **“실행계획을 생성→즉시 실행”**하는 구조  
2) 언어에 상관없이 공통적으로 발생하는 계획 구성 문제 해결  
3) 모듈 기반으로 기능 무한 확장 가능  
4) 비동기/병렬/조건 처리까지 DSL에 내장 → AI 추론 부담 제거  
5) ExecutionContext로 상태 관리 자동  
6) 결정론적 실행으로 안정성 확보  
7) 언어 중립적·AI 친화적 설계  

QPlan은 자동화 시스템에서  
**AI가 스스로 실행 가능한 계획을 만들고, 안전하게 실행하는 기반 아키텍처**이다.

© gyu — QPlan DSL Documentation (v4)
